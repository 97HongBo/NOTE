### Python里面search() 和match () 的区别

* match() 函数只检测RE是不是在string的开始位置匹配，search()会扫描整个string查找匹配，也就是说match()只有在0 位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match() 就返回none

### 用Python匹配HTML tag 的时候，<.* > 和 <. *?> 有什么区别？

* 前者是贪婪匹配，会从头到尾匹配`<a>XYZ</a>`,而后者是非贪婪匹配，只匹配到第一个`>`

### src = "security/afafsff/?ip= 127.0.0.1&id = 3306",请写一段代码用正则匹配出ip

* `re.findall(r'([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])',src)`

### 平衡点问题

* 平衡点：比如numbers = [1,3,5,7,8,25,4,20];25前面的总和为24,25后面的总和为24,25这个点就是平衡点；假如一个列表中的元素，其前面的部分等于后面的部分，那么这个点的位序就是平衡点

* 要求：返回任何一个平衡点

* 想法：使用sum函数累加所有的数。使用一个变量fore 累加系列的前部，直到满足条件fore < (total-number)/2;

* ```python
  numbers = [1,3,5,7,8,25,4,20]
  #累加数字
  total = sum(numbers)
  #寻找数字
  fore = 0 
  for number in numbers:
      if fore < (total-number)/2:
          fore += number
      else:
          break
  #输出答案
  if fore == (total-number)/2:
      print number
  else:
      print("not found")
  ```

### * args,**kwargs的作用是什么？如何使用？

* *args和**kwargs通常使用在函数定义里
* *args允许函数传入不定量的非关键字参数
* **kwargs允许函数传入不定量个数的关键字参数

### 对多线程和多进程的理解

* 进程时系统进行资源分配和调度的一个独立单位，线程是进程的一个实体，是cpu调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源；
* 一个程序至少有一个进程，一个进程至少有一个线程；
* 线程的划分尺度小于进程（资源比进程少）。使得多线程程序的并发性高；
* 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高程序的运行效率；
* 线程不能够独立执行，必须依存在进程中；
* 优缺点：线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反

### Python是怎么进行内存管理的？

* 引用计数：python内部使用引用计数，来保持追踪内存中的对象，python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，他被垃圾回收。
  * 引用计数加1的情况：
    * 对象被创建：x = 4
    * 另外的别人被创建：y = 4
    * 被作为参数传递给函数：foo(x)
    * 作为容器对象的一个元素：a=[1,x,'33']
  * 引用计数减少的情况
    * 一个本地引用离开了他的作用域，比如上面的foo(x)函数结束时，x指向的对象引用减1.
    * 对象的别名被显式的销毁：del x;或者del  y;
    * 对象的一个别名被显式的赋值给其他对象：x = 789
    * 对象从一个窗口对象中移除：myList.remove(x)
    * 窗口对象本身被销毁： del  myList 或者窗口对象本身离开了作用域
* 垃圾回收
  * 当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。它会去检查哪些引用计数为0的对象，然后清除其在内存的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉：当两个对象相互引用时，他们本身其他的引用已经为0了
  * 垃圾回收机制还有一个循环垃圾回收器，确保释放循环引用对象（a引用b，b引用a，导致其引用计数永远不为0）。
* 内存池机制：在python中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请并不是为了创建对象，所有并没有对象一级的内存池机制。这就意味着python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响python的执行效率。为了加速python的执行效率，python引入一个内存池机制，用于管理对小块内存的申请和释放。
  * python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
  * python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。另外python对象，如整数，浮点数和list，都有其独立的私有池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数

### python中如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别）

* 赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。
* 浅拷贝：创建一个新的对象，但他包含的是对原始对象中包含项的引用（如果引用的方式修改其中一个对象，另外一个改变）
* 深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）

### 有没有一个工具可以帮助查找python的bug和进行静态的代码分析？

* PyChecker是一个python代码的静态分析工具，他可以帮助查找python代码的bug，会对代码的复杂度和格式提出警告
* Pylint是另外的一个工具可以进行codingstandard检查

### 请阐述`__new__和__init__`的区别？

* `__new__`创建对象时调用，会返回当前对象的一个实例
* `__init__`创建对象后调用，对当前对象的一些实例初始化，无返回值
* 调用顺序：先调用`__new__`生成一个实例再调用`__init___`方法对实例进行初始化，比如添加属性

### 简单阐述一下cookie和session的关系，以及csrf的攻击和防范方法

* cookie保存在浏览器端，session保存在服务端，但是为了区分不同的客户端，服务器会在浏览器中发送一个对应的sessionid保存到cookies中，下次浏览器请求服务器的时候会将sessionid一并发送给服务器。所以session机制依赖于cookie机制。
* csrf共计：cross site request forgery 跨站请求伪造
  * 原理：
    * User（C） 访问信任网站Web （A），Web（A）会在User （C）处设置A的cookie
    * User  （C）在没有登录A 的情况下，访问危险网站Web （B），B要求User （C）访问Web（A）
    * User （C） 在Web （B） 的要求下，带着Web（A）的cookie访问Web（A），这样Web（B）就达到了模拟用户操作的目的
  * 防御：
    * 通过 referer,token 或者验证码来检测用户提交
    * 尽量不要在页面的链接中暴露用户隐私信息。
    * 对于用户修改删除等操作最好都使用post操作
    * 避免全站通用的cookie，严格设置cookie的域

